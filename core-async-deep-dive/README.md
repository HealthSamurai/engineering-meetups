# core.async: Deep Dive
- Unraveling the internals of Clojure's asynchronous programming engine

| 10 December, 2025 | 18:00 (GMT+1) | Online / Zoom | Free (but invaluable) |
|:-----------------:|:-------------:|:-------------:|:---------------------:|

**>> [Get an Invitation!](https://team.health-samurai.io/core-async/?utm_source=github)**

**FAQ**

|         For whom?        |    What's the format?    |    Who is the speaker?   |       How to join?       |
|:-------------------------|:-------------------------|:-------------------------|:-------------------------|
|- Language implementers considering async support for your language<br>- Clojure developers wanting to level up beyond API usage<br>- Systems programmers curious about CSP-style concurrency<br>- Anyone who's ever looked at a Go block and thought "but how?"|- Speaker’s presentation ~45 minutes<br>- Q&A session<br>- Discussion on the topic<br> <br>The entire meetup will last one to one and a half hours|**Andrey Listopadov**, Clojure Engineer at Health Samurai<br> <br>Andrey has been programming in Clojure professionally for 5+ years, with deep expertise in both the language and its ecosystem. He's a conference speaker, open-source contributor, and notably has ported Clojure's core.async to Fennel — giving him firsthand knowledge of how the library works at its deepest level.|Just fill out **[the registration form](https://team.health-samurai.io/core-async#rec1634368451)**, send your information, and get an invitation by email.<br> <br>Please provide your real information, because we might reach out to you for networking or even with an invitation to speak at a meetup with us! :)|

**MORE ABOUT THE TALK**

**Intro from speaker**<br>
An in‑depth look at the internals of clojure.core.async and what they mean for asynchronous programming in Clojure. We will go past the public API and examine what really happens under the hood when you spin up asynchronous processes and pass messages over channels.​​

**What this talk covers:**
- The internal structure of channels, queues, timers, and event loops, and how they work together to drive asynchronous workflows.​
- How “virtual threads” are compiled and scheduled, and why this model fits Clojure so well.​​
- How the macro system is used to implement core.async﻿ semantics and transform ordinary Clojure code into state machines.​​

**Who should attend**
- Programming language designers and implementers exploring ways to add asynchronous execution to their language.​​
- Clojure developers who use core.async﻿ today or are evaluating it for production systems.​
- Engineers interested in how asynchronous processes and message‑passing channels really work beneath the abstractions.​

**After this talk, you will:**
- Clearly understand the difference between asynchrony and parallelism, and when each model is appropriate.​
- Have a mental model of the internal mechanisms of clojure.core.async﻿ and be able to judge where this approach fits their own projects.​
- Gain a deeper understanding of how asynchronous “threads” and channels are implemented, helping them design more robust concurrent systems.

**>> [Get an Invitation!](https://team.health-samurai.io/core-async/?utm_source=github)**


**— Will it be interesting if I already know the topic well?**<br>
Of course! We’ll be happy if you join the discussion after the talk and share your experience. Your perspective will help reveal the topic more fully for the participants.

**— If I don’t understand the topic of the talk at all, will it still be clear to me?**<br>
Absolutely! Usually, at the beginning of the talk, the speaker introduces the participants to the problem area. Even if something remains unclear to you, you can freely ask the speaker your question — after all, there are no stupid questions.


![Image alt](https://github.com/HealthSamurai/engineering-meetups/blob/main/core-async-deep-dive/core-async-cover.png)

